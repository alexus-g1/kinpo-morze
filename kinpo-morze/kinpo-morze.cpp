// kinpo-morze.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <map>
#include <fstream>
#include "functions.h"
using namespace std;

/*!Cловарь для хранения данных вида {буква на азбуке Морзе, ее перевод}*/
map <string, char> dict = { {".-", 'А'},{"-...", 'Б'},{".--",'В'},
                                  {"--.", 'Г'},{"-..",'Д'},{".",'Е'},
                                  {"...-",'Ж'},{"--..",'З'},{"..",'И'},
                                  {".---",'Й'},{"-.-",'К'},{".-..",'Л'},
                                  {"--",'М'},{"-.",'Н'},{"---",'О'},
                                  {".--.",'П'},{".-.",'Р'},{"...",'С'},
                                  {"-",'Т'},{".--",'У'},{"..-.",'Ф'},
                                  {"....",'Х'},{"-.-.",'Ц'},{"---.",'Ч'},
                                  {"----",'Ш'},{"--.-",'Щ'},{".--.-.",'Ъ'},
                                  {"-.--",'Ы'},{"-..-",'Ь'},
                                  {"..-..",'Э'},{"..--",'Ю'},{".-.-",'Я'},
                                  {"-----",'0'},{".----",'1'},{"..---",'2'},
                                  {"...--",'3'},{"....-",'4'},{".....",'5'},
                                  {"-....",'6'},{"--...",'7'},{"---..",'8'},
                                  {"----.",'9'} };

/*!Массив содержащий список ошибок*/
const string errors[5] = { "Не указан файл входных данных",
                            "Не верно указан файл фходных данных, возможно файл не существует",
                            "Слишком много символов в сообщении (больше 50)",
                            "Файл входных данных - пустой",
                            "Недопустимые символы в сообщении" };



int main()
{
    ofstream out;       //поток выходных данных
    ifstream in;        //поток входных данных
    string path;        //Путь к файлу
    string morzeString; //Строка для хранения сообщения на морзе

    //открываем(cоздаем) файл выходных данных
    out.open("results.txt");

    //Ввод 
    cin >> path;

    try
    {
        //Вызвать исключение если путь не указан
        if (path.length() == 0) throw 0;

        //Открыть файл с входными данными
        in.open(path);

        //Вызвать исключение если файл не открылся
        if (!in.is_open()) throw 1;

        //Получить строку на языке Морзе из файла...
        char ch;
        while (in.get(ch))
        {
            morzeString.append(1, ch);
        }

        //Закрыть файл входных данных
        in.close();

        //Проверить строку морзе на корректность
        checkInput(morzeString);
    }
    catch (int errorIndex)
    {
        //Обработать исключение и вывести соответствующую ошибку
        out << errors[errorIndex];
    }

    vector <string> results; //Вектор для хранения вариантов расшифровки

    //Получить все возможные варианты расшифровки
    decodeMorze(morzeString, "", results);

    //Записать полученные варианты в файл выходных данных
    vector <string> ::iterator it = results.begin();
    for (it; it != results.end(); it++)
    {
        out << *it << "\n";
    }

    out.close();
}

void checkInput(const string morzeString)
{
    //Вызвать исключение если строка пустая
    if (morzeString.length() > 50) throw 2;

    //Вызвать исключение если в строке больше 50 символов
    if (morzeString.length() == 0) throw 3;

    //для каждого символа в строке
    for (int i = 0; i < morzeString.length(); i++)
    {
        //Вызвать исключение если символ не “точка” или не “тире”
        if (morzeString[i] != '.' && morzeString[i] != '-') throw 4;
    }
}

void decodeMorze(const string srcString, string currentDecodedString, vector <string>& variants)
{
    //Если строка не пустая
    if (!srcString.empty())
    {
        //для каждого элемента в словаре морзе
        for (auto& elem : dict)
        {
            //если элемент словаря совпадает с началом строки
            if (srcString.find(elem.first) == 0)
            {
                //записать в конец строки для перевода соответствующую элементу словаря букву 
                currentDecodedString.push_back(elem.second);

                //Рекурсивно вызвать эту же функцию, используя новые значения промежуточных данных и копию исходной строки без первой буквы
                decodeMorze(srcString.substr(elem.first.length()), currentDecodedString, variants);

                //удалить из строки для перевода последнюю букву
                currentDecodedString.pop_back();
            }
        }
    }
    else
    {
        //добавить строку с промежуточными данными в список возможных  переводов
        variants.push_back(currentDecodedString);
    }
}
